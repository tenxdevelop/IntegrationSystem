# IntegrationSystem
## Группа 1
Проект реализует интеграционное приложение на базе n8n для синхронизации данных о запчастях между тремя системами:

-  **CMS** (эмулируется внешним API) - источник актуальных данных о деталях;
-  **БД исторических данных** (PostgreSQL) - хранит полную историю изменений и актуальное состояние;
-  **Report API** (то же внешнее API) - принимает CSV- файлы с текущим состоянием БД.

Основная задача решения - обеспечить:
1. загрузку и версионирование данных из CMS;
2. отслеживание актуальности позиций (включая «ушедшие из оборота»);
3. формирование CSV- среза и отправку его в систему отчётности.

- - - 

## Архитектура и потоки данных
БД:
<img width="695" height="621" alt="image" src="https://github.com/user- attachments/assets/e468fa97- b1b6- 435b- a4c8- 20fd81c895a3" />

В проекте реализовано два воркфлоу n8n:

### 1. Workflow 'Import Data to DB'

Этот воркфлоу отвечает за синхронизацию данных из CMS в PostgreSQL.

1. **Загрузка данных из CMS**  
   Воркфлоу запускается вручную (узел 'Manual Trigger') и использует 'Set' для задания базового URL API и 'studentId'. Далее узел 'Code in JavaScript' опрашивает CMS по endpoint’у '/students/1/cms/spares', обходит страницы (пагинация) и собирает полный список деталей.

2. **Нормализация данных**  
   Узел 'Normilize' приводит входные данные к удобному для БД виду: парсит цену в число, нормализует дату 'updatedAt' к SQL- формату 'TIMESTAMP' и сохраняет как сырые значения (priceRaw, updatedAtRaw), так и нормализованные.

3. **Запись в БД с историчностью**  
   Узел 'Execute a SQL query' выполняет SQL- скрипт:
   -  закрывает предыдущую актуальную версию записи в 'spares_history' (ставит 'is_current = FALSE' и 'valid_to = NOW()'), если данные по детали изменились;
   -  вставляет новую версию записи в 'spares_history', если таких данных ещё нет;
   -  обновляет «сырые» поля для актуальной версии;
   -  поддерживает таблицу 'spares_current' с последним состоянием по каждой детали через 'INSERT ... ON CONFLICT (spare_code) DO UPDATE'.

4. **Обработка ушедших из оборота деталей**  
   Узел 'Collect Codes' собирает все коды деталей, полученные из CMS за текущий запуск. Затем 'Close missing' обновляет 'spares_history', помечая как неактуальные ('is_current = FALSE', 'valid_to = NOW()') те записи, чьи 'spare_code' больше не присутствуют в актуальном списке CMS. Таким образом в БД остаются исторические записи даже для удалённых из CMS деталей.

![import- workflow](https://github.com/user- attachments/assets/421fd50f- 4e53- 4b64- 87bb- 1f263b9be2ea)


### 2. Workflow 'Export DB to Report API'

Этот воркфлоу отвечает за формирование CSV на основе БД и отправку его в Report API.

1. **Получение актуальных данных из БД**  
   Воркфлоу запускается вручную, через 'Set' задаются 'baseUrl' и 'studentId'. Узел 'Execute a SQL query' вытягивает из 'spares_history' по одной последней  версии на каждый 'spare_code' (используется 'DISTINCT ON (spare_code)' и фильтр 'is_current = TRUE'), формируя набор полей в формате, ожидаемом Report API:  
   'spareCode', 'spareName', 'spareDescription', 'spareType', 'spareStatus', 'price', 'quantity', 'updatedAt'.

2. **Формирование CSV- файла**  
   Узел 'Convert to File' конвертирует массив записей в CSV- файл:
   -  разделитель - ";";
   -  заголовок не добавляется ('headerRow: false');
   -  кодировка по умолчанию UTF- 8

3. **Отправка в Report API**  
   Узел 'HTTP Request' отправляет сформированный CSV в Report API
   с заголовком 'Content- Type: text/csv' и телом в виде бинарных данных (поле 'data'). Таким образом система отчётности получает актуальный снимок состояния исторической БД.
![export- workflow](https://github.com/user- attachments/assets/1bbf5df7- b5a1- 45bf- a4f1- c2e0dcf84198)


